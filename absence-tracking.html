<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¸»æ—¥ç¼ºå‹¤è®°å½•</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1400px;
      margin: 20px auto;
      padding: 20px;
    }
    h1 {
      color: #333;
    }
    .controls {
      margin: 20px 0;
      padding: 20px;
      background: #f5f5f5;
      border-radius: 8px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .calc-btn {
      background: #28a745;
    }
    .calc-btn:hover {
      background: #218838;
    }
    .event-btn {
      background: #ff9800;
    }
    .event-btn:hover {
      background: #f57c00;
    }
    .result-panel {
      margin: 20px 0;
      padding: 20px;
      background: white;
      border-radius: 8px;
      border: 2px solid #e0e0e0;
    }
    .stat-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #ddd;
      text-align: center;
    }
    .stat-label {
      color: #666;
      font-size: 14px;
      margin-bottom: 5px;
    }
    .stat-value {
      font-size: 32px;
      font-weight: bold;
    }
    .group-section {
      margin-bottom: 20px;
      border-left: 4px solid #2196f3;
      padding-left: 15px;
    }
    .group-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }
    .member-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .member-tag {
      display: inline-block;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
      color: white;
    }
    .tag-1 { background: #9e9e9e; }
    .tag-2 { background: #ffc107; }
    .tag-3 { background: #ff9800; }
    .tag-high { background: #f44336; }
  </style>
</head>
<body>
  <h1>ä¸»æ—¥ç¼ºå‹¤è®°å½•</h1>
  
  <div class="controls">
    <button onclick="window.location.href='summary.html'">è¿”å›æ±‡æ€»</button>
    <button class="calc-btn" onclick="calculateLatestWeek()">è®¡ç®—æœ€æ–°ä¸€å‘¨</button>
    <button class="event-btn" onclick="window.location.href='absence-events.html'">ğŸ“‹ äº‹ä»¶ç®¡ç†</button>
  </div>
  
  <!-- æœ¬å‘¨è®¡ç®—ç»“æœ -->
  <div class="result-panel" id="currentWeekPanel">
    <h2>æœ¬å‘¨è®¡ç®—ç»“æœ</h2>
    <div id="currentWeekContent">
      <p style="text-align: center; color: #999;">ç‚¹å‡»"è®¡ç®—æœ€æ–°ä¸€å‘¨"æŒ‰é’®æŸ¥çœ‹</p>
    </div>
  </div>
  
  <!-- ä¸Šå‘¨è®¡ç®—ç»“æœ -->
  <div class="result-panel" id="lastWeekPanel">
    <h2>ä¸Šå‘¨è®¡ç®—ç»“æœ</h2>
    <div id="lastWeekContent">
      <p style="text-align: center; color: #999;">ç‚¹å‡»"è®¡ç®—æœ€æ–°ä¸€å‘¨"æŒ‰é’®æŸ¥çœ‹</p>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  
  <script src="./src/smart-config-loader.js"></script>
  <script>
    let db;
    let groupNames = {};
    let memberMapCache = null;
    
    // åˆå§‹åŒ–Firebase
    async function initFirebase() {
      let attempts = 0;
      while (!window.firebaseConfig && attempts < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      
      if (!window.firebaseConfig) {
        throw new Error('Firebaseé…ç½®åŠ è½½è¶…æ—¶');
      }
      
      if (!firebase.apps.length) {
        firebase.initializeApp(window.firebaseConfig);
      }
      db = firebase.database();
      console.log('Firebaseåˆå§‹åŒ–æˆåŠŸ');
    }
    
    // åŠ è½½å°ç»„åç§°
    async function loadGroupNames() {
      const snapshot = await db.ref('groupNames').once('value');
      groupNames = snapshot.val() || {};
    }

    function buildMemberMap(groups) {
      const members = [];
      const nameToUuid = {};
      const uuidToMember = {};
      
      Object.entries(groups).forEach(([groupKey, groupMembers]) => {
        if (!Array.isArray(groupMembers)) {
          return;
        }
        groupMembers.forEach(member => {
          if (member.excluded) {
            return;
          }
          const uuid = member.uuid || member.memberUUID || member.name;
          if (!uuid) {
            return;
          }
          members.push({
            uuid,
            name: member.name,
            group: groupKey
          });
          if (member.name) {
            nameToUuid[member.name] = uuid;
          }
          const nickname = member.nickname || member.Nickname || member.èŠ±å || member.alias;
          if (nickname) {
            nameToUuid[nickname] = uuid;
          }
          uuidToMember[uuid] = {
            uuid,
            name: member.name,
            group: groupKey
          };
        });
      });
      
      return {
        members,
        nameToUuid,
        uuidToMember
      };
    }

    function resolveRecordUUID(record, memberMap) {
      if (!record || !memberMap) {
        return null;
      }
      
      if (record.memberUUID) {
        return record.memberUUID;
      }
      if (record.memberSnapshot && record.memberSnapshot.uuid) {
        return record.memberSnapshot.uuid;
      }
      if (record.uuid) {
        return record.uuid;
      }
      const candidateNames = [
        record.memberName,
        record.name,
        record.memberSnapshot?.name,
        record.memberSnapshot?.nickname,
        record.memberSnapshot?.èŠ±å,
        record.nickname,
        record.alias
      ];
      for (const candidate of candidateNames) {
        if (candidate && memberMap.nameToUuid[candidate]) {
          return memberMap.nameToUuid[candidate];
        }
      }
      return null;
    }

    async function resolveMemberActiveEventsIfNeeded(memberUUID, sundayDate, memberEventsMap, latestClosureMap) {
      if (!memberUUID) {
        return;
      }
      
      let memberEvents = memberEventsMap ? memberEventsMap[memberUUID] || [] : null;
      
      if (!memberEvents) {
        const eventsSnapshot = await db.ref('absenceEvents')
          .orderByChild('memberUUID')
          .equalTo(memberUUID)
          .once('value');
        
        if (!eventsSnapshot.exists()) {
          return;
        }
        
        memberEvents = [];
        eventsSnapshot.forEach(child => {
          memberEvents.push({
            id: child.key,
            ...child.val()
          });
        });
        if (memberEventsMap) {
          memberEventsMap[memberUUID] = memberEvents;
        }
      }
      
      const updates = {};
      let updated = false;
      const resolvedTimestamp = new Date(sundayDate).getTime();
      
      memberEvents.forEach(event => {
        if (event.status === 'active' && (!event.weeks || !event.weeks.includes(sundayDate))) {
          updates[event.id] = {
            ...event,
            status: 'resolved',
            resolvedDate: sundayDate,
            updatedAt: new Date().toISOString()
          };
          updated = true;
        }
      });
      
      if (updated) {
        await db.ref('absenceEvents').update(updates);
        if (memberEventsMap) {
          memberEventsMap[memberUUID] = memberEvents.map(event => {
            if (updates[event.id]) {
              return {
                ...updates[event.id]
              };
            }
            return event;
          });
        }
        if (latestClosureMap && !Number.isNaN(resolvedTimestamp)) {
          latestClosureMap[memberUUID] = {
            timestamp: resolvedTimestamp,
            date: sundayDate
          };
        }
      }
    }
    
    // è·å–æœ€æ–°ä¸»æ—¥æ—¥æœŸ
    function getLatestSunday() {
      const today = new Date();
      const day = today.getDay();
      const diff = day === 0 ? 0 : -day;
      const sunday = new Date(today);
      sunday.setDate(today.getDate() + diff);
      return sunday.toISOString().split('T')[0];
    }
    
    // è·å–ä¸Šä¸€ä¸ªä¸»æ—¥æ—¥æœŸ
    function getPreviousSunday(dateStr) {
      const date = new Date(dateStr);
      date.setDate(date.getDate() - 7);
      return date.toISOString().split('T')[0];
    }
    
    // æ˜¾ç¤ºè®¡ç®—ç»“æœ
    function displayCalcResult(sundayDate, calcResult, signedCount, targetDiv) {
      const absenceCount = Object.keys(calcResult).length;
      
      // è·å–æ‰€æœ‰æˆå‘˜æ•°
      const totalMembers = memberMapCache ? memberMapCache.members.length : 0;
      
      // ç”Ÿæˆç»Ÿè®¡å¡ç‰‡
      let html = `
        <div class="stat-cards">
          <div class="stat-card">
            <div class="stat-label">æ—¥æœŸ</div>
            <div class="stat-value" style="color: #2196f3; font-size: 24px;">${sundayDate}</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">ç­¾åˆ°äººæ•°</div>
            <div class="stat-value" style="color: #28a745;">${signedCount}</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">ç¼ºå‹¤äººæ•°</div>
            <div class="stat-value" style="color: #f44336;">${absenceCount}</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">æ€»æˆå‘˜</div>
            <div class="stat-value" style="color: #666;">${totalMembers}</div>
          </div>
        </div>
      `;
      
      // æŒ‰ç»„åˆ«åˆ†ç»„æ˜¾ç¤ºç¼ºå‹¤äººå‘˜
      const absenceByGroup = {};
      Object.entries(calcResult).forEach(([uuid, data]) => {
        const group = data.group;
        if (!absenceByGroup[group]) {
          absenceByGroup[group] = [];
        }
        absenceByGroup[group].push({
          name: data.name,
          count: data.count
        });
      });
      
      // æ’åºï¼šå…ˆæŒ‰ç¼ºå‹¤æ¬¡æ•°ï¼Œå†æŒ‰å§“å
      Object.values(absenceByGroup).forEach(members => {
        members.sort((a, b) => {
          if (a.count !== b.count) return b.count - a.count;
          return a.name.localeCompare(b.name);
        });
      });
      
      const sortedGroups = Object.keys(absenceByGroup).sort();
      
      if (sortedGroups.length > 0) {
        html += '<div style="margin-top: 20px;">';
        sortedGroups.forEach(groupKey => {
          const groupName = groupNames[groupKey] || groupKey;
          const members = absenceByGroup[groupKey];
          
          html += `
            <div class="group-section">
              <div class="group-title">${groupName} (${members.length}äºº)</div>
              <div class="member-tags">
          `;
          
          members.forEach(m => {
            const tagClass = m.count === 1 ? 'tag-1' : (m.count === 2 ? 'tag-2' : (m.count === 3 ? 'tag-3' : 'tag-high'));
            html += `<span class="member-tag ${tagClass}">${m.name} (${m.count}æ¬¡)</span>`;
          });
          
          html += `
              </div>
            </div>
          `;
        });
        html += '</div>';
      } else {
        html += '<p style="text-align: center; color: #28a745; font-size: 18px; margin-top: 20px;">ğŸ‰ æœ¬å‘¨å…¨å‘˜ç­¾åˆ°ï¼</p>';
      }
      
      targetDiv.innerHTML = html;
    }
    
    // è®¡ç®—æœ€æ–°ä¸€å‘¨
    async function calculateLatestWeek() {
      const btn = event.target;
      btn.disabled = true;
      btn.textContent = 'è®¡ç®—ä¸­...';
      
      try {
        const latestSunday = getLatestSunday();
        const prevSunday = getPreviousSunday(latestSunday);
        
        console.log('è®¡ç®—æœ€æ–°ä¸€å‘¨:', latestSunday);
        
        // è·å–groupsç¼“å­˜
        const groupsSnapshot = await db.ref('groups').once('value');
        window.cachedGroups = groupsSnapshot.val() || {};
        memberMapCache = buildMemberMap(window.cachedGroups);
        
        // è®¡ç®—æœ¬å‘¨
        await calculateWeek(latestSunday);
        
        // æ˜¾ç¤ºæœ¬å‘¨ç»“æœ
        await loadWeekResult(latestSunday, 'currentWeekContent');
        
        // æ˜¾ç¤ºä¸Šå‘¨ç»“æœ
        await loadWeekResult(prevSunday, 'lastWeekContent');
        
        alert('è®¡ç®—å®Œæˆï¼');
        
      } catch (error) {
        console.error('è®¡ç®—å¤±è´¥:', error);
        alert('è®¡ç®—å¤±è´¥: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = 'è®¡ç®—æœ€æ–°ä¸€å‘¨';
      }
    }
    
    // è®¡ç®—æŸå‘¨
    async function calculateWeek(sundayDate) {
      console.log(`è®¡ç®— ${sundayDate}...`);
      
      if (!memberMapCache) {
        memberMapCache = buildMemberMap(window.cachedGroups || {});
      }
      
      // 1. è·å–ç­¾åˆ°æ•°æ®
      const snapshot = await db.ref('attendanceRecords')
        .orderByChild('date')
        .equalTo(sundayDate)
        .once('value');
      
      const attendance = [];
      if (snapshot.exists()) {
        snapshot.forEach(child => {
          attendance.push(child.val());
        });
      }
      
      const signedUUIDs = new Set();
      const missingUuidLogs = [];
      const unresolvedRecords = [];
      
      attendance.forEach(record => {
        const resolvedUUID = resolveRecordUUID(record, memberMapCache);
        if (resolvedUUID) {
          signedUUIDs.add(resolvedUUID);
          if (!record.memberUUID && (record.memberName || record.name)) {
            missingUuidLogs.push(resolvedUUID);
          }
        } else {
          unresolvedRecords.push(record);
        }
      });
      
      console.log('æœ¬å‘¨ç­¾åˆ°äººæ•°(å»é‡):', signedUUIDs.size);
      if (missingUuidLogs.length > 0) {
        console.log(`æç¤ºï¼šé€šè¿‡åç§°åŒ¹é…è¡¥é½UUID ${missingUuidLogs.length} æ¡`);
      }
      if (unresolvedRecords.length > 0) {
        const preview = unresolvedRecords.slice(0, 5).map(record => record.memberName || record.name || record.memberSnapshot?.name || JSON.stringify(record));
        console.warn(`å­˜åœ¨ ${unresolvedRecords.length} æ¡æ— æ³•åŒ¹é…UUIDçš„ç­¾åˆ°è®°å½•`, preview);
      }
      
      // 2. è·å–æ‰€æœ‰æˆå‘˜
      const allMembers = memberMapCache.members;
      console.log('æ€»æˆå‘˜æ•°:', allMembers.length);
      
      // 3. è·å–ä¸Šå‘¨çš„è®¡ç®—ç»“æœ
      const prevSunday = getPreviousSunday(sundayDate);
      const prevSnapshot = await db.ref(`absenceCalc/${prevSunday}`).once('value');
      const prevCalc = prevSnapshot.val() || {};

      // 4. è¯»å–äº‹ä»¶ä¿¡æ¯ï¼Œå¤„ç†æ‰‹åŠ¨å…³é—­åçš„çŠ¶æ€é‡ç½®
      const eventsSnapshot = await db.ref('absenceEvents').once('value');
      const memberEventsMap = {};
      const latestClosureMap = {};
      
      eventsSnapshot.forEach(child => {
        const event = child.val();
        const eventId = child.key;
        const uuid = event.memberUUID;
        if (!uuid) {
          return;
        }
        if (!memberEventsMap[uuid]) {
          memberEventsMap[uuid] = [];
        }
        memberEventsMap[uuid].push({
          id: eventId,
          ...event
        });
        
        if (event.status && event.status !== 'active') {
          const closureDate = event.resolvedDate || event.updatedAt || event.endDate;
          if (closureDate) {
            const closureTime = new Date(closureDate).getTime();
            if (!Number.isNaN(closureTime)) {
              const current = latestClosureMap[uuid];
              if (!current || closureTime > current.timestamp) {
                latestClosureMap[uuid] = {
                  timestamp: closureTime,
                  date: closureDate
                };
              }
            }
          }
        }
      });

      // 5. æ¸…é™¤å·²æœ‰æ ‡è®°ï¼ˆç­¾åˆ°å³è§†ä¸ºæ¢å¤ï¼‰
      for (const uuid of signedUUIDs) {
        if (prevCalc[uuid]) {
          console.log(`${prevCalc[uuid].name || uuid} æœ¬å‘¨å·²ç­¾åˆ°ï¼Œæ¸…é™¤ç¼ºå‹¤æ ‡è®°ï¼ˆä¹‹å‰${prevCalc[uuid].count}æ¬¡ï¼‰`);
        }
        await resolveMemberActiveEventsIfNeeded(uuid, sundayDate, memberEventsMap, latestClosureMap);
      }
      
      // 6. è®¡ç®—æœ¬å‘¨ç¼ºå‹¤
      const currentCalc = {};
      const eventsToSave = {};
      
      for (const member of allMembers) {
        const uuid = member.uuid;
        
        if (signedUUIDs.has(uuid)) {
          continue;
        }
        
        // ç¼ºå‹¤
        const prevSundayTime = new Date(prevSunday).getTime();
        const closureInfo = latestClosureMap[uuid];
        let prevCount = prevCalc[uuid] ? prevCalc[uuid].count : 0;
        if (closureInfo && !Number.isNaN(prevSundayTime) && closureInfo.timestamp >= prevSundayTime) {
          prevCount = 0;
        }
        const newCount = prevCount + 1;
        
        if (prevCount === 0) {
          console.log(`${member.name} é¦–æ¬¡ç¼ºå‹¤ï¼Œæ ‡è®°ä¸º1æ¬¡`);
        } else {
          console.log(`${member.name} è¿ç»­ç¼ºå‹¤ï¼Œæ¬¡æ•° ${prevCount} -> ${newCount}`);
        }
        
        currentCalc[uuid] = {
          count: newCount,
          name: member.name,
          group: member.group,
          date: sundayDate
        };
        
        // å¤„ç†äº‹ä»¶
        if (newCount >= 2) {
          if (prevCount === 1 && newCount === 2) {
            // æ–°äº‹ä»¶
            const eventId = `${uuid}_${sundayDate}`;
            eventsToSave[eventId] = {
              memberUUID: uuid,
              memberName: member.name,
              group: member.group,
              startDate: prevSunday,
              endDate: sundayDate,
              count: newCount,
              weeks: [prevSunday, sundayDate],
              status: 'active',
              createdAt: new Date().toISOString()
            };
          } else if (prevCount >= 2) {
            const memberEvents = memberEventsMap[uuid] || [];
            memberEvents.forEach(event => {
              if (event.status === 'active') {
                eventsToSave[event.id] = {
                  ...event,
                  endDate: sundayDate,
                  count: newCount,
                  weeks: [...(event.weeks || []), sundayDate].filter((v, i, a) => a.indexOf(v) === i),
                  updatedAt: new Date().toISOString()
                };
              }
            });
          }
        }
      }
      
      // 6. ä¿å­˜ç»“æœ
      if (Object.keys(currentCalc).length > 0) {
        await db.ref(`absenceCalc/${sundayDate}`).set(currentCalc);
        console.log('ä¿å­˜è®¡ç®—ç»“æœ:', Object.keys(currentCalc).length, 'äººç¼ºå‹¤');
      } else {
        await db.ref(`absenceCalc/${sundayDate}`).set({});
        console.log('ä¿å­˜è®¡ç®—ç»“æœ: 0 äººç¼ºå‹¤');
      }
      
      if (Object.keys(eventsToSave).length > 0) {
        await db.ref('absenceEvents').update(eventsToSave);
        console.log('ä¿å­˜äº‹ä»¶:', Object.keys(eventsToSave).length, 'ä¸ª');
      }
    }
    
    // åŠ è½½æŸå‘¨çš„è®¡ç®—ç»“æœ
    async function loadWeekResult(sundayDate, targetDivId) {
      try {
        // è·å–è®¡ç®—ç»“æœ
        const calcSnapshot = await db.ref(`absenceCalc/${sundayDate}`).once('value');
        const calcResult = calcSnapshot.val() || {};
        
        // è·å–ç­¾åˆ°æ•°æ®
        const snapshot = await db.ref('attendanceRecords')
          .orderByChild('date')
          .equalTo(sundayDate)
          .once('value');
        
        if (!memberMapCache) {
          memberMapCache = buildMemberMap(window.cachedGroups || {});
        }
        
        const attendance = [];
        if (snapshot.exists()) {
          snapshot.forEach(child => {
            attendance.push(child.val());
          });
        }
        
        const signedUUIDs = new Set();
        attendance.forEach(record => {
          const resolvedUUID = resolveRecordUUID(record, memberMapCache);
          if (resolvedUUID) {
            signedUUIDs.add(resolvedUUID);
          }
        });
        const signedCount = signedUUIDs.size;
        const targetDiv = document.getElementById(targetDivId);
        
        displayCalcResult(sundayDate, calcResult, signedCount, targetDiv);
        
      } catch (error) {
        console.error('åŠ è½½è®¡ç®—ç»“æœå¤±è´¥:', error);
        document.getElementById(targetDivId).innerHTML = `<p style="color: red;">åŠ è½½å¤±è´¥: ${error.message}</p>`;
      }
    }
    
    // é¡µé¢åŠ è½½
    window.addEventListener('load', async () => {
      await initFirebase();
      await loadGroupNames();
      
      // è‡ªåŠ¨åŠ è½½æœ¬å‘¨å’Œä¸Šå‘¨çš„è®¡ç®—ç»“æœ
      const latestSunday = getLatestSunday();
      const prevSunday = getPreviousSunday(latestSunday);
      
      // ç¼“å­˜groupsæ•°æ®
      const groupsSnapshot = await db.ref('groups').once('value');
      window.cachedGroups = groupsSnapshot.val() || {};
      memberMapCache = buildMemberMap(window.cachedGroups);
      
      await loadWeekResult(latestSunday, 'currentWeekContent');
      await loadWeekResult(prevSunday, 'lastWeekContent');
    });
  </script>
</body>
</html>
