# 缺勤计算逻辑错误修复说明

**日期**: 2025-11-07  
**问题**: 已签到成员仍然显示连续缺勤14周

---

## 🔴 问题原因

### 错误的逻辑
```javascript
// ❌ 错误代码
if (signedUUIDs.has(uuid)) {
  // 有签到，忽略（不保存到Firebase）
  continue;
}

// 保存时使用update()
await db.ref(`absenceCalc/${sundayDate}`).update(currentCalc);
```

**问题**：
1. 有签到时，只是"忽略"，不保存到Firebase
2. 但上周的缺勤标记还在Firebase中
3. 下周计算时，从Firebase读取上周数据，标记依然存在
4. 导致标记一直累加，即使中途有签到也无法清除

**举例**：
- 第1周：陈林缺勤 → 标记1，保存到Firebase
- 第2周：陈林签到 → "忽略"，不保存
- 第3周：陈林缺勤 → 读取Firebase，发现标记1还在 → 标记2
- 第4周：陈林签到 → "忽略"，不保存
- 第5周：陈林缺勤 → 读取Firebase，发现标记2还在 → 标记3
- ...累加到14周

---

## ✅ 修复方案

### 正确的逻辑
```javascript
// ✅ 修复后
if (signedUUIDs.has(uuid)) {
  // 🔴 关键修复：有签到时，清除缺勤标记
  const prevCount = prevCalcResult && prevCalcResult[uuid] ? prevCalcResult[uuid].count : 0;
  if (prevCount > 0) {
    log(`${member.name} 恢复签到，清除缺勤标记（之前${prevCount}次）`, 'info');
  }
  // 不保存到currentCalc，这样Firebase中就不会有该成员的数据
  continue;
}

// 🔴 关键：使用set()覆盖整周数据，这样签到的人不会保留上周的标记
await db.ref(`absenceCalc/${sundayDate}`).set(currentCalc);
```

**修复关键点**：
1. **使用`set()`而非`update()`**：覆盖整周数据
2. **不保存已签到成员**：`currentCalc`中只包含缺勤成员
3. **自动清除标记**：Firebase中只保留本周缺勤的成员，签到的成员会被自动清除

**举例**：
- 第1周：陈林缺勤 → 标记1，Firebase: `{陈林: {count:1}}`
- 第2周：陈林签到 → 不在currentCalc中，set()覆盖，Firebase: `{其他缺勤成员...}`（陈林被清除）
- 第3周：陈林缺勤 → 读取Firebase，没有陈林的标记 → 标记1（重新开始）
- 第4周：陈林签到 → 清除标记
- 第5周：陈林缺勤 → 标记1（重新开始）

---

## 🎯 为什么使用`set()`而非`update()`

### Firebase数据结构
```
absenceCalc/
  2025-08-03/
    uuid1: {count: 1}
    uuid2: {count: 2}
  2025-08-10/
    uuid1: {count: 2}  ← 如果uuid1签到了，这条应该被删除
    uuid3: {count: 1}
```

### update() vs set()

**update()** - 增量更新：
- 只更新指定的字段
- 不删除其他字段
- ❌ 无法清除已签到成员的标记

**set()** - 覆盖更新：
- 覆盖整个节点的数据
- 删除未包含在新数据中的字段
- ✅ 自动清除已签到成员的标记

---

## 📋 修复后的完整流程

### 第1周（2025-08-03）
1. 获取签到数据：成员A、B有签到
2. 对比所有成员：成员C、D、E缺勤
3. 计算：C=1, D=1, E=1
4. 保存：`set({C:1, D:1, E:1})`

### 第2周（2025-08-10）
1. 获取签到数据：成员A、C有签到（C恢复签到）
2. 对比所有成员：成员B、D、E缺勤
3. 读取上周：C=1, D=1, E=1
4. 计算：
   - C有签到 → 不保存（清除标记）
   - D缺勤 → D=2，**生成事件**
   - E缺勤 → E=2，**生成事件**
   - B缺勤 → B=1（新缺勤）
5. 保存：`set({B:1, D:2, E:2})`  ← C的标记被自动清除

### 第3周（2025-08-17）
1. 获取签到数据：成员A、D有签到（D恢复签到）
2. 对比所有成员：成员B、C、E缺勤
3. 读取上周：B=1, D=2, E=2
4. 计算：
   - D有签到 → 不保存（清除标记）
   - B缺勤 → B=2，**生成事件**
   - C缺勤 → C=1（重新开始缺勤）
   - E缺勤 → E=3，**更新事件**
5. 保存：`set({B:2, C:1, E:3})`  ← D的标记被自动清除

---

## ⚠️ 重要提醒

### 重新运行计算工具

修复后，需要**重新运行计算工具**，从8月开始重新计算所有数据：

1. 清空Firebase中的旧数据（可选）：
   ```
   absenceCalc - 删除所有子节点
   absenceEvents - 删除所有子节点
   ```

2. 重新运行计算工具：
   - 访问 `tools/msh-system/absence-calculator.html`
   - 点击"开始计算（9月至今）"

3. 验证结果：
   - 查看 `absence-tracking.html`
   - 确认10月有签到的成员不会显示连续缺勤

---

## 📊 预期结果

修复后：
- ✅ 成员有签到 → 缺勤标记被清除
- ✅ 下次缺勤 → 从1开始重新计算
- ✅ 10月有签到的成员 → 不会显示14周连续缺勤
- ✅ 事件列表准确反映当前连续缺勤情况

---

**修复版本**: v3.1  
**修复日期**: 2025-11-07

