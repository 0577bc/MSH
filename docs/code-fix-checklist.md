# 代码修复前强制检查清单

**目的**: 确保代码修复前充分探索现有代码，避免重复实现已有功能  
**优先级**: 🔴 P0级 - 必须执行（不可跳过）  
**适用场景**: 所有代码修复、功能修复、Bug修复

---

## 🚨 P0级 - 代码修复前强制检查

### ✅ 阶段1: 代码探索（必须执行）

#### 1.1 多维度关键词搜索
- [ ] **功能关键词搜索**
  - 使用 `codebase_search` 搜索功能相关关键词
  - 搜索同义词、近义词、相关术语
  - 示例：修复"缺勤计算"时，应搜索：
    - `calculate`, `absence`, `tracking`, `连续缺勤`
    - `缺勤`, `计算`, `统计`, `跟踪`
  
- [ ] **函数名模式搜索**
  - 使用 `grep -r "关键词"` 搜索函数名
  - 搜索变量名、类名、对象属性
  - 搜索相关文件的命名模式

- [ ] **文件路径搜索**
  - 查找相关功能文件
  - 使用 `find . -name "*关键词*"` 搜索文件名
  - 查看相关目录结构

#### 1.2 查看工具类/管理器完整API
- [ ] **识别相关工具类**
  - 确定功能相关的Manager、Utils、Helper类
  - 查看类的完整定义
  - 列出所有可用方法

- [ ] **查看方法定义**
  - 使用 `grep -A 50 "class\|object\|Manager\|Utils"` 查看完整定义
  - 理解方法的参数、返回值、功能说明
  - 查看方法的使用示例

- [ ] **确认可用方法**
  - 确认是否有现成的方法可以调用
  - 确认方法是否满足需求
  - 确认是否需要扩展还是直接使用

#### 1.3 查看函数调用关系
- [ ] **查找所有调用位置**
  - 使用 `grep -r "functionName"` 查找所有调用
  - 理解函数在哪些地方被使用
  - 理解函数的依赖关系

- [ ] **理解数据流向**
  - 绘制数据流向图
  - 理解函数的输入输出
  - 理解函数在整个系统中的作用

---

### ✅ 阶段2: 现有功能检查（必须执行）

#### 2.1 确认是否有已存在的类似功能
- [ ] **搜索相似功能**
  - 搜索是否有相同或相似功能的函数
  - 查看历史修复记录
  - 查看相关文档和注释

- [ ] **检查现有解决方案**
  - 确认是否有现成的解决方案
  - 确认是否有相关的工具函数
  - 确认是否有相关的管理器

#### 2.2 确认是否可以通过调用现有函数解决
- [ ] **评估现有功能**
  - 评估现有函数是否完全满足需求
  - 评估是否需要扩展现有函数
  - 评估是否需要组合多个函数

- [ ] **设计方案**
  - 如果现有功能可用，直接使用
  - 如果功能相似，考虑扩展
  - 如果需要组合，设计调用方案

---

### ✅ 阶段3: 方案设计（必须执行）

#### 3.1 优先使用现有功能
- [ ] **复用优于重写**
  - 如果已有相同功能，直接使用，不要重新实现
  - 如果功能相似，考虑扩展现有功能而非新建
  - 保持代码复用性

- [ ] **最小化修改**
  - 只修改必要的部分
  - 避免大范围重构
  - 保持向后兼容

#### 3.2 维护成本评估
- [ ] **代码复杂度评估**
  - 评估修改后的代码复杂度
  - 确保代码简洁易懂
  - 避免过度设计

- [ ] **维护成本分析**
  - 评估后续维护成本
  - 考虑代码可读性
  - 考虑团队理解成本

---

## 📋 执行验证清单

在执行代码修复前，必须在对话中明确说明：

1. ✅ **搜索了哪些关键词**
   - 列出所有搜索的关键词
   - 说明搜索范围和结果

2. ✅ **查看了哪些工具类的API**
   - 列出查看的工具类
   - 列出相关方法列表
   - 说明哪些方法可用

3. ✅ **发现了哪些现有功能**
   - 列出发现的现有功能
   - 说明功能是否满足需求
   - 说明为什么选择/不选择使用

4. ✅ **为什么选择当前的实现方案**
   - 说明方案选择的理由
   - 说明为什么没有使用现有功能（如果适用）
   - 说明方案的优缺点

---

## ⚠️ 违反后果

如果跳过代码探索步骤，可能导致：

- ❌ **重复实现已有功能**
  - 浪费开发时间
  - 增加代码复杂度
  - 造成代码冗余

- ❌ **代码复杂度增加**
  - 从简单的函数调用变成复杂的实现
  - 从20+行代码变成200+行代码
  - 增加维护成本

- ❌ **系统不稳定**
  - 新实现的代码可能有Bug
  - 与现有系统可能不兼容
  - 可能导致系统故障

---

## 📚 相关文档

- [代码索引文档](./CODE_INDEX.md) - 关键函数位置索引
- [修改工作流](../simple-memory-system/MODIFICATION-WORKFLOW.md) - 完整修改流程
- [记忆系统规则生效性分析](./reports/MEMORY_SYSTEM_EFFECTIVENESS_ANALYSIS_2025-11-05.md) - 规则分析

---

## 🎯 使用示例

### 正确的修复流程

```
1. 问题描述: 主日跟踪页面连续缺勤显示不准确

2. 代码探索:
   - ✅ 搜索关键词: calculate, absence, tracking, 缺勤, 计算
   - ✅ 查看 SundayTrackingManager 的完整API
   - ✅ 发现 calculateConsecutiveAbsences() 函数
   - ✅ 发现 generateTrackingList() 函数

3. 现有功能检查:
   - ✅ 确认 calculateConsecutiveAbsences() 已实现所需功能
   - ✅ 确认 generateTrackingList() 可以生成所有事件

4. 方案设计:
   - ✅ 直接使用 generateTrackingList() 替代复杂逻辑
   - ✅ 代码从200+行简化为20+行
   - ✅ 复用现有功能，维护成本低
```

---

**重要提醒**: 
- 此检查清单是P0级规则，必须严格执行
- 跳过检查可能导致重复实现和代码复杂度增加
- 如有疑问，请参考 [代码索引文档](./CODE_INDEX.md) 或相关文档


