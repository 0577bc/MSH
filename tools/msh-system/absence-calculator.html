<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç¼ºå‹¤è®¡ç®—å·¥å…·</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
    }
    h1 {
      color: #333;
    }
    .controls {
      margin: 20px 0;
      padding: 20px;
      background: #f5f5f5;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .log {
      margin-top: 20px;
      padding: 15px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      max-height: 500px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
    }
    .log-item {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    .log-success {
      color: green;
    }
    .log-error {
      color: red;
    }
    .log-info {
      color: blue;
    }
    .progress {
      margin: 10px 0;
      padding: 10px;
      background: #e9ecef;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <h1>ç¼ºå‹¤è®¡ç®—å·¥å…·</h1>
  
  <div class="controls">
    <button id="startBtn" onclick="startCalculation()">å¼€å§‹è®¡ç®—ï¼ˆ9æœˆè‡³ä»Šï¼‰</button>
    <button id="backBtn" onclick="window.history.back()">è¿”å›</button>
    <div class="progress" id="progress" style="display:none;"></div>
  </div>
  
  <div class="controls">
    <label for="sundayDate">æŸ¥çœ‹ç‰¹å®šä¸»æ—¥:</label>
    <input type="date" id="sundayDate" />
    <button onclick="viewSpecificSunday()">æŸ¥çœ‹ç¼ºå‹¤æ•°æ®</button>
  </div>
  
  <div id="specificResult" style="display:none; margin: 20px 0; padding: 20px; background: #e3f2fd; border-radius: 8px;">
    <h3>ğŸ“Š ç¼ºå‹¤æ•°æ®è¯¦æƒ…</h3>
    <div id="resultContent"></div>
  </div>
  
  <div class="log" id="log"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
  
  <script src="../../src/smart-config-loader.js"></script>
  <script>
    let db;
    
    // åˆå§‹åŒ–Firebase
    async function initFirebase() {
      // ç­‰å¾…é…ç½®åŠ è½½
      let attempts = 0;
      while (!window.firebaseConfig && attempts < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      
      if (!window.firebaseConfig) {
        throw new Error('Firebaseé…ç½®åŠ è½½è¶…æ—¶');
      }
      
      if (!firebase.apps.length) {
        firebase.initializeApp(window.firebaseConfig);
      }
      db = firebase.database();
      log('Firebaseåˆå§‹åŒ–æˆåŠŸ', 'success');
    }
    
    // æ—¥å¿—å‡½æ•°
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const item = document.createElement('div');
      item.className = `log-item log-${type}`;
      item.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(item);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }
    
    // æ›´æ–°è¿›åº¦
    function updateProgress(current, total) {
      const progressDiv = document.getElementById('progress');
      progressDiv.style.display = 'block';
      progressDiv.textContent = `è¿›åº¦: ${current}/${total} (${Math.round(current/total*100)}%)`;
    }
    
    // è·å–æ‰€æœ‰ä¸»æ—¥æ—¥æœŸï¼ˆä»startDateåˆ°ä»Šå¤©ï¼‰
    function getSundayDates(startDate, endDate) {
      const sundays = [];
      let current = new Date(startDate);
      const end = new Date(endDate);
      
      while (current <= end) {
        if (current.getDay() === 0) { // å‘¨æ—¥
          sundays.push(current.toISOString().split('T')[0]);
        }
        current.setDate(current.getDate() + 1);
      }
      
      return sundays;
    }
    
    // è·å–æŸå‘¨çš„ä¸»æ—¥ç­¾åˆ°æ•°æ®
    async function getWeekAttendance(sundayDate) {
      log(`æŸ¥è¯¢ ${sundayDate} ç­¾åˆ°æ•°æ®...`, 'info');
      
      // ğŸ”´ ä¿®å¤ï¼šä½¿ç”¨dateå­—æ®µæŸ¥è¯¢ï¼ˆYYYY-MM-DDæ ¼å¼ï¼‰ï¼Œè€Œä¸æ˜¯timestamp
      const snapshot = await db.ref('attendanceRecords')
        .orderByChild('date')
        .equalTo(sundayDate)
        .once('value');
      
      const records = [];
      if (snapshot.exists()) {
        snapshot.forEach(child => {
          const record = child.val();
          records.push(record);
        });
      }
      
      if (records.length > 0) {
        log(`æ‰¾åˆ° ${records.length} æ¡ç­¾åˆ°è®°å½•`, 'success');
      } else {
        log('æœªæ‰¾åˆ°ç­¾åˆ°è®°å½•', 'info');
      }
      
      return records;
    }
    
    // è·å–æ‰€æœ‰æˆå‘˜ï¼ˆæ’é™¤æ’é™¤äººå‘˜ï¼‰
    async function getAllMembers() {
      const snapshot = await db.ref('groups').once('value');
      const groups = snapshot.val() || {};
      
      const members = [];
      Object.entries(groups).forEach(([groupKey, groupMembers]) => {
        groupMembers.forEach(member => {
          // æ’é™¤æ ‡è®°ä¸ºexcludedçš„æˆå‘˜
          if (!member.excluded) {
            members.push({
              uuid: member.uuid || member.name,
              name: member.name,
              group: groupKey
            });
          }
        });
      });
      
      return members;
    }
    
    // è®¡ç®—æŸå‘¨çš„ç¼ºå‹¤æƒ…å†µ
    async function calculateWeek(sundayDate, prevCalcResult) {
      log(`========== è®¡ç®— ${sundayDate} ==========`, 'info');
      
      // 1. è·å–æœ¬å‘¨ç­¾åˆ°æ•°æ®
      const attendance = await getWeekAttendance(sundayDate);
      const memberMap = await buildMemberMap();
      const signedUUIDs = new Set();
      const unresolvedRecords = [];
      const missingUuidLogs = [];

      attendance.forEach(record => {
        const resolvedUUID = resolveRecordUUID(record, memberMap);
        if (resolvedUUID) {
          signedUUIDs.add(resolvedUUID);
          if (!record.memberUUID && (record.memberName || record.name)) {
            missingUuidLogs.push(resolvedUUID);
          }
        } else {
          unresolvedRecords.push(record);
        }
      });

      if (missingUuidLogs.length > 0) {
        log(`æç¤ºï¼šæœ¬å‘¨æœ‰ ${missingUuidLogs.length} æ¡ç­¾åˆ°è®°å½•é€šè¿‡åç§°åŒ¹é…è¡¥é½UUIDã€‚`, 'info');
      }
      if (unresolvedRecords.length > 0) {
        const unresolvedPreview = unresolvedRecords.slice(0, 5).map(record => record.memberName || record.name || record.memberSnapshot?.name || JSON.stringify(record));
        log(`âš ï¸ æœ‰ ${unresolvedRecords.length} æ¡ç­¾åˆ°è®°å½•æ— æ³•åŒ¹é…åˆ°æˆå‘˜UUIDï¼ˆç¤ºä¾‹: ${unresolvedPreview.join(', ')}ï¼‰`, 'error');
      }

      // 2. æ¸…é™¤æœ¬å‘¨å·²ç­¾åˆ°äººå‘˜çš„ç¼ºå‹¤æ ‡è®°
      if (prevCalcResult) {
        signedUUIDs.forEach(uuid => {
          if (prevCalcResult[uuid]) {
            const member = memberMap.uuidToMember[uuid];
            const displayName = member ? member.name : uuid;
            log(`${displayName} æœ¬å‘¨å·²ç­¾åˆ°ï¼Œæ¸…é™¤ç¼ºå‹¤æ ‡è®°ï¼ˆä¹‹å‰${prevCalcResult[uuid].count}æ¬¡ï¼‰`, 'info');
          }
        });
      }

      // 3. è®¡ç®—ç¼ºå‹¤ï¼ˆä»…æŒ‰æ ‡è®°é€»è¾‘ï¼‰
      const currentCalc = {};
      const allMembers = memberMap.members;

      for (const member of allMembers) {
        const uuid = member.uuid;
        
        if (signedUUIDs.has(uuid)) {
          await resolveMemberActiveEventsIfNeeded(member, sundayDate);
          continue;
        }
        
        const prevCount = prevCalcResult && prevCalcResult[uuid] ? prevCalcResult[uuid].count : 0;
        const newCount = prevCount + 1;
        if (prevCount === 0) {
          log(`${member.name} é¦–æ¬¡ç¼ºå‹¤ï¼Œæ ‡è®°ä¸º1æ¬¡`, 'info');
        } else {
          log(`${member.name} è¿ç»­ç¼ºå‹¤ï¼Œæ¬¡æ•° ${prevCount} â†’ ${newCount}`, 'info');
        }
        
        currentCalc[uuid] = {
          count: newCount,
          name: member.name,
          group: member.group,
          date: sundayDate
        };
      }
      
      // 4. ä¿å­˜è®¡ç®—ç»“æœåˆ°Firebase
      // ğŸ”´ å…³é”®ï¼šä½¿ç”¨set()è¦†ç›–æ•´å‘¨æ•°æ®ï¼Œè¿™æ ·ç­¾åˆ°çš„äººä¸ä¼šä¿ç•™ä¸Šå‘¨çš„æ ‡è®°
      const absenceCount = Object.keys(currentCalc).length;
      
      if (absenceCount > 0) {
        await db.ref(`absenceCalc/${sundayDate}`).set(currentCalc);
        log(`âœ… ä¿å­˜è®¡ç®—ç»“æœï¼š${absenceCount} äººç¼ºå‹¤`, 'success');
      } else {
        await db.ref(`absenceCalc/${sundayDate}`).set({});
        log('âœ… ä¿å­˜è®¡ç®—ç»“æœï¼šæœ¬å‘¨å…¨å‘˜ç­¾åˆ°', 'success');
      }
      
      // 5. ç”Ÿæˆ/æ›´æ–°äº‹ä»¶ï¼ˆæ ‡è®°>=2ï¼‰
      await processEvents(sundayDate, currentCalc, prevCalcResult);
      await closeResolvedEvents(signedUUIDs, prevCalcResult, sundayDate, memberMap.uuidToMember);
      
      return currentCalc;
    }
    
    // å¤„ç†äº‹ä»¶ç”Ÿæˆå’Œæ›´æ–°
    async function processEvents(sundayDate, currentCalc, prevCalcResult) {
      const eventsToSave = {};
      
      for (const [uuid, data] of Object.entries(currentCalc)) {
        if (data.count >= 2) {
          // éœ€è¦ç”Ÿæˆæˆ–æ›´æ–°äº‹ä»¶
          const prevCount = prevCalcResult && prevCalcResult[uuid] ? prevCalcResult[uuid].count : 0;
          
          if (prevCount === 1 && data.count === 2) {
            // æ–°äº‹ä»¶ï¼šä»æ ‡è®°1å˜ä¸ºæ ‡è®°2
            const eventId = `${uuid}_${sundayDate}`;
            
            // è®¡ç®—å¼€å§‹å‘¨ï¼ˆä¸Šä¸€å‘¨ï¼‰
            const startDate = new Date(sundayDate);
            startDate.setDate(startDate.getDate() - 7);
            const startWeek = startDate.toISOString().split('T')[0];
            
            eventsToSave[eventId] = {
              memberUUID: uuid,
              memberName: data.name,
              group: data.group,
              startDate: startWeek,
              endDate: sundayDate,
              count: data.count,
              weeks: [startWeek, sundayDate],
              status: 'active',
              createdAt: new Date().toISOString()
            };
            
            log(`ç”Ÿæˆäº‹ä»¶: ${data.name} (${data.group}) - ${startWeek}è‡³${sundayDate}`, 'success');
          } else if (prevCount >= 2) {
            // æ›´æ–°ç°æœ‰äº‹ä»¶
            // æ‰¾åˆ°è¯¥æˆå‘˜çš„äº‹ä»¶
            const eventsSnapshot = await db.ref('absenceEvents')
              .orderByChild('memberUUID')
              .equalTo(uuid)
              .once('value');
            
            if (eventsSnapshot.exists()) {
              eventsSnapshot.forEach(child => {
                const eventId = child.key;
                const event = child.val();
                
                // åªæ›´æ–°æ´»è·ƒäº‹ä»¶
                if (event.status === 'active') {
                  eventsToSave[eventId] = {
                    ...event,
                    endDate: sundayDate,
                    count: data.count,
                    weeks: [...(event.weeks || []), sundayDate].filter((v, i, a) => a.indexOf(v) === i), // å»é‡
                    updatedAt: new Date().toISOString()
                  };
                  
                  log(`æ›´æ–°äº‹ä»¶: ${data.name} - ç¼ºå‹¤${data.count}æ¬¡`, 'info');
                }
              });
            }
          }
        }
      }
      
      // æ‰¹é‡ä¿å­˜äº‹ä»¶
      if (Object.keys(eventsToSave).length > 0) {
        await db.ref('absenceEvents').update(eventsToSave);
      }
    }

    async function closeResolvedEvents(signedUUIDs, prevCalcResult, sundayDate, uuidToMember) {
      if (!prevCalcResult) {
        return;
      }
      const updates = {};
      for (const uuid of signedUUIDs) {
        if (!prevCalcResult[uuid]) {
          continue;
        }
        const member = uuidToMember[uuid];
        const displayName = member ? member.name : uuid;
        const eventsSnapshot = await db.ref('absenceEvents')
          .orderByChild('memberUUID')
          .equalTo(uuid)
          .once('value');
        if (!eventsSnapshot.exists()) {
          continue;
        }
        eventsSnapshot.forEach(child => {
          const event = child.val();
          const eventId = child.key;
          if (event.status === 'active') {
            updates[eventId] = {
              ...event,
              status: 'resolved',
              resolvedDate: sundayDate,
              updatedAt: new Date().toISOString()
            };
            log(`âœ… å…³é—­äº‹ä»¶: ${displayName} - ç¼ºå‹¤ç»“æŸäº ${sundayDate}`, 'success');
          }
        });
      }
      if (Object.keys(updates).length > 0) {
        await db.ref('absenceEvents').update(updates);
      }
    }

    async function resolveMemberActiveEventsIfNeeded(member, sundayDate) {
      const memberUUID = member.uuid;
      if (!memberUUID) {
        return;
      }
      const eventsSnapshot = await db.ref('absenceEvents')
        .orderByChild('memberUUID')
        .equalTo(memberUUID)
        .once('value');
      if (!eventsSnapshot.exists()) {
        return;
      }
      const updates = {};
      eventsSnapshot.forEach(child => {
        const event = child.val();
        const eventId = child.key;
        if (event.status === 'active' && (!event.weeks || !event.weeks.includes(sundayDate))) {
          updates[eventId] = {
            ...event,
            status: 'resolved',
            resolvedDate: sundayDate,
            updatedAt: new Date().toISOString()
          };
          log(`âœ… æˆå‘˜é‡æ–°ç­¾åˆ°ï¼Œå…³é—­äº‹ä»¶: ${member.name} (${member.group})`, 'success');
        }
      });
      if (Object.keys(updates).length > 0) {
        await db.ref('absenceEvents').update(updates);
      }
    }

    async function buildMemberMap() {
      const members = await getAllMembers();
      const nameToUuid = {};
      const uuidToMember = {};
      members.forEach(member => {
        if (member.name) {
          nameToUuid[member.name] = member.uuid;
        }
        if (member.uuid) {
          uuidToMember[member.uuid] = member;
        }
      });
      return {
        members,
        nameToUuid,
        uuidToMember
      };
    }

    function resolveRecordUUID(record, memberMap) {
      if (record.memberUUID) {
        return record.memberUUID;
      }
      if (record.memberSnapshot && record.memberSnapshot.uuid) {
        return record.memberSnapshot.uuid;
      }
      if (record.memberName && memberMap.nameToUuid[record.memberName]) {
        return memberMap.nameToUuid[record.memberName];
      }
      if (record.name && memberMap.nameToUuid[record.name]) {
        return memberMap.nameToUuid[record.name];
      }
      if (record.memberSnapshot && record.memberSnapshot.name && memberMap.nameToUuid[record.memberSnapshot.name]) {
        return memberMap.nameToUuid[record.memberSnapshot.name];
      }
      return null;
    }
    
    // ä¸»è®¡ç®—æµç¨‹
    async function startCalculation() {
      const startBtn = document.getElementById('startBtn');
      startBtn.disabled = true;
      
      try {
        log('å¼€å§‹åˆå§‹åŒ–...', 'info');
        await initFirebase();
        
        // è·å–æ‰€æœ‰ä¸»æ—¥æ—¥æœŸï¼ˆä»2025-09-01åˆ°ä»Šå¤©ï¼‰
        const today = new Date().toISOString().split('T')[0];
        const sundays = getSundayDates('2025-09-01', today);
        log(`æ‰¾åˆ° ${sundays.length} ä¸ªä¸»æ—¥éœ€è¦è®¡ç®—`, 'info');
        
        let prevCalcResult = null;
        
        for (let i = 0; i < sundays.length; i++) {
          const sunday = sundays[i];
          updateProgress(i + 1, sundays.length);
          
          // è®¡ç®—æœ¬å‘¨
          prevCalcResult = await calculateWeek(sunday, prevCalcResult);
          
          // å»¶è¿Ÿï¼Œé¿å…Firebaseå‹åŠ›è¿‡å¤§
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
        log('==============================', 'success');
        log('è®¡ç®—å®Œæˆï¼', 'success');
        log(`å…±è®¡ç®— ${sundays.length} å‘¨æ•°æ®`, 'success');
        
      } catch (error) {
        log(`é”™è¯¯: ${error.message}`, 'error');
        console.error(error);
      } finally {
        startBtn.disabled = false;
      }
    }
    
    // æŸ¥çœ‹ç‰¹å®šä¸»æ—¥çš„ç¼ºå‹¤æ•°æ®
    async function viewSpecificSunday() {
      const dateInput = document.getElementById('sundayDate');
      const sundayDate = dateInput.value;
      
      if (!sundayDate) {
        alert('è¯·é€‰æ‹©æ—¥æœŸï¼');
        return;
      }
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºå‘¨æ—¥
      const date = new Date(sundayDate);
      if (date.getDay() !== 0) {
        alert('è¯·é€‰æ‹©å‘¨æ—¥ï¼');
        return;
      }
      
      try {
        // åˆå§‹åŒ–Firebase
        if (!db) {
          await initFirebase();
        }
        
        log(`========== æŸ¥çœ‹ ${sundayDate} çš„ç¼ºå‹¤æ•°æ® ==========`, 'info');
        
        // 1. è·å–è¯¥å‘¨çš„ç­¾åˆ°æ•°æ®
        const attendance = await getWeekAttendance(sundayDate);
        const memberMap = await buildMemberMap();
        const signedUUIDs = new Set();
        const unresolvedRecords = [];
        const duplicateTracker = {};
        attendance.forEach(record => {
          const resolvedUUID = resolveRecordUUID(record, memberMap);
          if (resolvedUUID) {
            signedUUIDs.add(resolvedUUID);
            if (!duplicateTracker[resolvedUUID]) {
              duplicateTracker[resolvedUUID] = {
                count: 0,
                names: new Set()
              };
            }
            duplicateTracker[resolvedUUID].count += 1;
            const displayName = record.memberName || record.name || memberMap.uuidToMember[resolvedUUID]?.name || resolvedUUID;
            duplicateTracker[resolvedUUID].names.add(displayName);
          } else {
            unresolvedRecords.push(record);
          }
        });
        
        log(`æœ¬å‘¨ç­¾åˆ°äººæ•°: ${signedUUIDs.size}`, 'success');
        if (Object.keys(duplicateTracker).length > 0) {
          const duplicates = Object.values(duplicateTracker).filter(item => item.count > 1);
          if (duplicates.length > 0) {
            const duplicateMessages = duplicates.slice(0, 10).map(item => `${Array.from(item.names).join('/')}: ${item.count} æ¡è®°å½•`);
            log(`å‘ç° ${duplicates.length} ä½æˆå‘˜å­˜åœ¨å¤šæ¡ç­¾åˆ°è®°å½•ï¼Œå‰10é¡¹ï¼š${duplicateMessages.join('; ')}`, 'info');
          }
        }
        if (unresolvedRecords.length > 0) {
          const unresolvedPreview = unresolvedRecords.slice(0, 10).map(record => record.memberName || record.name || record.memberSnapshot?.name || JSON.stringify(record));
          log(`âš ï¸ æœ‰ ${unresolvedRecords.length} æ¡ç­¾åˆ°è®°å½•æ— æ³•åŒ¹é…åˆ°æˆå‘˜UUIDï¼Œå‰10æ¡ï¼š${unresolvedPreview.join(', ')}`, 'error');
        }
        
        // 2. è·å–æ‰€æœ‰æˆå‘˜
        const allMembers = memberMap.members;
        log(`æ€»æˆå‘˜æ•°ï¼ˆæ’é™¤åï¼‰: ${allMembers.length}`, 'info');
        
        // 3. è®¡ç®—ç¼ºå‹¤äººå‘˜
        const absenceMembers = [];
        for (const member of allMembers) {
          if (!signedUUIDs.has(member.uuid)) {
            absenceMembers.push(member);
          }
        }
        
        log(`ç¼ºå‹¤äººæ•°: ${absenceMembers.length}`, 'info');
        
        // 4. è·å–Firebaseä¸­çš„è®¡ç®—ç»“æœï¼ˆå¦‚æœæœ‰ï¼‰
        const calcSnapshot = await db.ref(`absenceCalc/${sundayDate}`).once('value');
        const savedCalc = calcSnapshot.val() || {};
        
        // 5. æ˜¾ç¤ºç»“æœ
        const resultDiv = document.getElementById('specificResult');
        const contentDiv = document.getElementById('resultContent');
        
        let html = `
          <p><strong>æ—¥æœŸï¼š</strong>${sundayDate}</p>
          <p><strong>ç­¾åˆ°äººæ•°ï¼š</strong>${signedUUIDs.size} äºº</p>
          <p><strong>ç¼ºå‹¤äººæ•°ï¼š</strong>${absenceMembers.length} äºº</p>
          <p><strong>æ€»æˆå‘˜æ•°ï¼š</strong>${allMembers.length} äºº</p>
          <p><strong>Firebaseä¸­ä¿å­˜çš„ç¼ºå‹¤è®°å½•ï¼š</strong>${Object.keys(savedCalc).length} æ¡</p>
          <hr>
          <h4>ç­¾åˆ°æˆå‘˜åˆ—è¡¨ï¼ˆå‰10äººï¼‰ï¼š</h4>
          <ul>
        `;
        
        const signedMembers = allMembers.filter(m => signedUUIDs.has(m.uuid));
        signedMembers.slice(0, 10).forEach(m => {
          html += `<li>${m.name} (${m.group})</li>`;
        });
        if (signedMembers.length > 10) {
          html += `<li>...è¿˜æœ‰ ${signedMembers.length - 10} äºº</li>`;
        }
        html += '</ul>';
        
        html += '<h4>ç¼ºå‹¤æˆå‘˜åˆ—è¡¨ï¼ˆå‰20äººï¼‰ï¼š</h4><ul>';
        absenceMembers.slice(0, 20).forEach(m => {
          const savedData = savedCalc[m.uuid];
          const count = savedData ? savedData.count : 'æœªä¿å­˜';
          html += `<li>${m.name} (${m.group}) - ç¼ºå‹¤æ ‡è®°: ${count}</li>`;
        });
        if (absenceMembers.length > 20) {
          html += `<li>...è¿˜æœ‰ ${absenceMembers.length - 20} äºº</li>`;
        }
        html += '</ul>';
        
        contentDiv.innerHTML = html;
        resultDiv.style.display = 'block';
        
        log('æŸ¥çœ‹å®Œæˆï¼', 'success');
        
      } catch (error) {
        log(`é”™è¯¯: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    // é¡µé¢åŠ è½½å®Œæˆ
    window.addEventListener('load', () => {
      log('é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»"å¼€å§‹è®¡ç®—"æŒ‰é’®å¼€å§‹', 'info');
      
      // è®¾ç½®æ—¥æœŸé€‰æ‹©å™¨çš„é»˜è®¤æ—¥æœŸä¸ºæœ€è¿‘çš„ä¸»æ—¥
      const today = new Date();
      const day = today.getDay();
      const diff = day === 0 ? 0 : -day;
      const lastSunday = new Date(today);
      lastSunday.setDate(today.getDate() + diff);
      document.getElementById('sundayDate').value = lastSunday.toISOString().split('T')[0];
    });
  </script>
</body>
</html>

